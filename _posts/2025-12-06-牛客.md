
## 排序中有复杂的比较条件，可以直接用结构体

vector.end()是vector的末尾下一个地址，所以不能直接访问*vector.end这样必错。
正确的做法是vector.back()取最后一个元素

#### vector::end( )返回的是vector最后一个元素后的”结束元素“

#### vector::back( )返回的是vector最后一个元素

#### 类比字符串，end( )返回的是’\0’，back( )返回的是字符串的最后一个字符

但是使用vector.back需要判断是否为空.


## 数组去重的方法
第一正种方法是简单的利用set的特性，这部分代码比较简单

set初始化可以用
``` c++
set<int> a(vec.begin(), vec.end());

然后再 vec.assign(vec.begin(), vec.end());
```

assign 是要replace content的

第二种方法使用sort + unique + erase；
注意unique会改变数组原本的分布，此时再对数组使用第二次unique会导致返回的迭代器失效。

所以记住，sort unique， erase必须是绑定到一起的
``` c++
sort(vec.begin(), vec.end());

vec.erase(unique(vec.begin(), vec.end()), vec.end());
```

第三种方法使用remove，多学一个函数吧

这里的remove能够删除指定的元素，这个不是vec自带的。是跟sort， unique共用的函数。。


## 判断一个字符串是否是另外一个字符串子序列的方法

贪心匹配第一个，因为如果第二个能找到，那么从第一个开始匹配也能找到，牛逼。

而当我们从前往后匹配，可以发现每次贪心地匹配靠前的字符是最优决策。


```c
    auto it = std::find(numbers.begin(), numbers.end(), value_to_find);
```
find可以取代index of. 但是注意，find返回的是迭代器，如果你想把迭代器变成索引，还需要加一个
```c
        std::cout << "Found " << value_to_find << " at index: " << std::distance(numbers.begin(), it) << std::endl;
```
find找不到的话会返回end()因此你用这个就可以判断find 有没有找到结果
注意c++中的index和iter不是一个概念， 
### index 转 iter
```c
auto it = s.begin() + index;
```
Iter转index
```c
index = std::distance(s.begin(), it);
```


### 使用c++ bitset
```
## 1. 首先必须用#include <bitset>
```
### bitset a = bitset<49>(s)， 这里的s可以是一个字符串，由01组成.
	bitset是从地位开始赋值的。nice。 a[0]是右边第一个数字
	2. 
	一些操作
``` c
bs[i] = 0;
bs.set(0).把右边第一位变成1。
bs.reset(0)，把右边第一位变成0.
## bs.flip(0)， 把右边第一位反转
## 
把所有值都变成1。 bs.set

向左移动补0, 像右移动也补0
```

如果一个函数返回一个引用，然后你把这个引用赋值给一个变量，他会自动执行深拷贝。
## 但是如果你返回一个指针，这个指针赋值给一个变量，不会执行深拷贝，但是会有生命周期的问题。因为如果你没有在堆上创建，那么原来的那个变量退出函数就消失了。
```c
std::bitset<100>* get_ptr() {
    // 1. 创建了一个临时对象
    // 2. .set() 修改它
    // 3. 取它的地址 (&) 并返回
    return &(std::bitset<100>{}.set()); 
} // <--- 关键点：函数结束，临时对象在这里被销毁！

int main() {
    auto* ptr = get_ptr(); 
    // 此时 ptr 指向的是一块已经被销毁的内存（悬垂指针）
    // 访问它会导致崩溃或乱码
    ptr->test(1); // BOOM! 💥
}
```
## sada

左值是长周期的，右值时短周期的。

加上&编译报错就是右值，否则是左值. 右值的赋值是copy value。左值的赋值是深拷贝。

std::move, 会把原来的引用给解引用了貌似。



给bitset 加1

``` c
 b = b ^= 0x1;

b = b.to_ulong() + 1;
```


如果要比较两个字符串字符是否相同，可以用排序后再比较，当然也可以直接用桶来比较。




##  HJ28 素数伴侣
计算配对的最大数量。匈牙利算法：先到先得，能让就让。 牛逼.
能让就让的意思不是说你立刻就让，是你找到了下家再让，找不到就不让。
注意恢复visited的值


## 找最长的回文字符串


## std::unique是移除相邻元素中重合的，必须和sort函数绑定

c++ 用remove_if 去做不改变原来顺序的去重操作。 牛逼

remove_if其实和unique都一样，都不改变数组的大小，而是按某个条件进行分区，符合条件给弄到前面去，不符合条件弄到后面去，最后返回一个指向后一个分区开头的迭代器。

remove_if是从前到后依次执行的。

```c
std::remove_if(str.begin(), str.end(), [&seen](char c) { if (seen.count(c)) { return true; // 应该移除（之前出现过） } else { seen.insert(c); return false; // 保留（第一次出现） } });
```

```
这个语法是lambda语法，[](){}, []里面用&去捕获外部变量，()里面是remove_if定义的值,{}是函数体
```