
## 排序中有复杂的比较条件，可以直接用结构体

vector.end()是vector的末尾下一个地址，所以不能直接访问*vector.end这样必错。
正确的做法是vector.back()取最后一个元素

#### vector::end( )返回的是vector最后一个元素后的”结束元素“

#### vector::back( )返回的是vector最后一个元素

#### 类比字符串，end( )返回的是’\0’，back( )返回的是字符串的最后一个字符

但是使用vector.back需要判断是否为空.


## 数组去重的方法
第一正种方法是简单的利用set的特性，这部分代码比较简单

set初始化可以用
``` c++
set<int> a(vec.begin(), vec.end());

然后再 vec.assign(vec.begin(), vec.end());
```

assign 是要replace content的

第二种方法使用sort + unique + erase；
注意unique会改变数组原本的分布，此时再对数组使用第二次unique会导致返回的迭代器失效。

所以记住，sort unique， erase必须是绑定到一起的
``` c++
sort(vec.begin(), vec.end());

vec.erase(unique(vec.begin(), vec.end()), vec.end());
```

第三种方法使用remove，多学一个函数吧

这里的remove能够删除指定的元素，这个不是vec自带的。是跟sort， unique共用的函数。。


## 判断一个字符串是否是另外一个字符串子序列的方法

贪心匹配第一个，因为如果第二个能找到，那么从第一个开始匹配也能找到，牛逼。

而当我们从前往后匹配，可以发现每次贪心地匹配靠前的字符是最优决策。


```c
    auto it = std::find(numbers.begin(), numbers.end(), value_to_find);
```
find可以取代index of. 但是注意，find返回的是迭代器，如果你想把迭代器变成索引，还需要加一个
```c
        std::cout << "Found " << value_to_find << " at index: " << std::distance(numbers.begin(), it) << std::endl;
```
find找不到的话会返回end()因此你用这个就可以判断find 有没有找到结果
注意c++中的index和iter不是一个概念， 
### index 转 iter
```c
auto it = s.begin() + index;
```
Iter转index
```c
index = std::distance(s.begin(), it);
```


p