
1. 购物车，其实就是01背包，状态转移复杂一点，先用一个三元组保存输入，c++中三元组是tuple. 注意dp的定义和主件的定义是不一样的。
	我在用vscode debug c++的时候，一开始使用原生的插件发现怎么配置launch.json都不行，永远无法弹出一个terminal让我去输入数据，最后下载了一个插件，Code LLDB，配置完之后解决
	![](../assets/2025-12-02-牛客刷题/file-20251202174610439.png)
2. 小人移动
	c++中的split函数是StringSpliter（string，delimiter）
	stringsteam在sstream 里面
	
``` c++
	string input;

	cin >> input;
	
	stringstream ss(input);
	
	string token;
	
	vector<string> tokens;
	
	while (getline(ss, token, ';')) {
	
	tokens.push_back(token);
	
	}
	
	for (auto temp : tokens) {
	
	cout << temp << endl;

}
```
	这题我用的是状态机，但是其实正则过滤也可以。
		`regex_match(string,**regex**(``"[0-9]*"``))`. 这里是说string是否全是数字，如果不是全数字就退出.第二个传的是regex这个对象
		string temp = token.substr(1); 取的是下标从1开始的字符串. 调用substr一定先判断长度, str.length()

3. 判断ip地址类型和子网掩码类型，注意你想凑出来一个32位的东西的时候，一定要用unsigned int，否则会溢出，变成负数
	新学一个判断子网掩码的方法：
```c++
	`bool` `is_mask(string ip){`

    `istringstream iss(ip);`

    `string seg;`

    `unsigned b = 0;`

    `while``(getline(iss,seg,``'.'``)) b = (b << 8) + stoi(seg);`

    `if``(!b)` `return` `false``;`

    `b = ~b + 1;`

    `if``(b == 1)` `return` `false``;` （子网掩码取反+1 只能有一个1. 而且这个值不能是1）

    `if``((b & (b-1)) == 0)` `return` `true``;`（判断只有一个1）

    `return` `false``;`

`}`
```
4. c++中拼接字符串，用+号就行，```c
    string age_as_string = to_string(age);
```
数字变字符串，还可以用stringstream
5. c++中中文字符是3个，find_first_of与find_last_of找的结果是不一样的，还有个很离谱的，find_first_of与find_last_of居然是找到子串中的一个字符就返回。
   
   substr第一个是pos，第二个参数是长度。
   find，第一个是str，第二个是起始位置，包含这个起始位置。
   
   加上label的代码默认会执行，所以goto到外层循环到时候不特殊处理还需要加一个额外的goto
```
"[^a-zA-Z0-9]" 特殊字符是这样判断的，可以连续a-zA-Z，表示非用^
regex_search(str, pattern)
直接使用这个正则表达式也行，牛逼
用正则判断是否有长度为3的重复子串。牛逼
您提供的正则表达式是：


`.*(...)(.*\\1).*`

这个表达式的作用是匹配一个字符串，**使得这个字符串中存在一个连续的、长度为 3 的子串，并且这个子串在后面某个位置再次出现。**

---

## 详细解释 🔍

|**部分**|**含义**|**解释**|
|---|---|---|
|`.*`|匹配任意字符（换行符除外）零次或多次。|匹配字符串的**开头**部分，直到第一个我们要捕获的 3 个字符子串。|
|`(...)`|**捕获组 1**：匹配任意字符三次。|匹配并**记住**一个**连续的 3 个字符**的子串（例如："abc"）。这就是我们要检查是否重复的子串。|
|`.*`|匹配任意字符零次或多次。|匹配第一个 3 个字符子串和第二个 3 个字符子串**之间**的任何内容。|
|`\1`|**反向引用**：引用捕获组 1 匹配的内容。|匹配和捕获组 `(...)` 中完全**相同**的 3 个字符子串。|
|`.*`|匹配任意字符零次或多次。|匹配字符串的**结尾**部分。|


6. 删除字符串中的字符
	find + erase(pos, 1)删除字符串中指定字符
7. 合唱队排队型，居然是最长递增子序列 + 最长递减子序列。 注意DP的定义是选择i的情况下最长的长度
	进行DP的时候，一定要注意一个初始值,这是由定义决定的。 不改变长度，每次dp前向移动的时候直接走一个初始值就行
8. 字符串排序，如果说是字符的排序，可以直接上桶排序，因为范围比较小。
	**isalpha()用来判断一个字符是否为字母**，如果是字符则返回非零，否则返回零。
	当你需要读取包括空格的字符串的时候，好像只能用getchar？ 非也，可以使用getline的


晚上回来先把简单的刷完


## 怎么用正则表达式取出某个值？


## 怎么用replace? 
- **替换子字符串：**
    cpp
```
    std::string str = "Hello World";
    size_t pos = str.find("World");
    if (pos != std::string::npos) {
        str.replace(pos, 5, "C++"); // 从 pos 开始，替换 5 个字符为 "C++"
    }
    // str 现在是 "Hello C++"
    ```
    
- **替换单个字符：**
    cpp```
    std::string str = "Hello World";
    size_t pos = str.find('o');
    if (pos != std::string::npos) {
        str.replace(pos, 1, "!"); // 从 pos 开始，替换 1 个字符为 "!"
    }
    // str 现在是 "Hell! World"
    ```
    
    
    replace传的是字符串，而非字符。
    a.replace(i, 1, " "); 合法而a.replace(i, 1, ‘ ’)不合法;
    



```



```cpp
    string::const_iterator searchStart( str.cbegin() );
    while ( regex_search( searchStart, str.cend(), res, exp ) )
    {
        cout << ( searchStart == str.cbegin() ? "" : " " ) << res[0];  
        searchStart = res.suffix().first;
    }
    cout << endl;
```

这里是一个c++用正则表达式匹配并输出所有结果的。

regex_search 可以传一个string，也可以传一个string的迭代器，起始和结束.
smatch, const_interator, results.suffix().first



sort函数给一个comparator就行，这个comparator就是一个返回bool值的东西。


c++创建动态二维数组，可以用vector或者用数组


``` c++
int **a = new int*[n];

for (int i = 0; i < n; i++)

{

a[i] = new int[n];

}

  

for (int i = 0; i < n; i++)

{

delete []a[i];

}

delete []a;
```


``` c++
vector<vector<int>> a(n, vector<int>(n));
```




## 怎么把float变成int？

``` c++
std::round()
```

想把float值的整数部分赋值给一个int变量
```c
int value = static_cast<int>(round(floatnum))

```


c++中class有构造函数，析构函数，new返回的是一个指针

new是一个o关键字，它会调用operator new，然后调用类的构造函数，最后返回指针

delete也是一个关键字。他会调用析构函数，然后调用operator delete，释放内存空间

c++ 在分配数组的时候总会多分配四个字节，用来指示数组的长度。


new [] 做的事情是分配长度+4个字节的地址空间，然后做构造函数
delete[] 做的事情就是依次去做析构（长度在前四个字节里面），然后释放地址空间。


如果你想直接创建对象数组，你需要给 `volunteer` 类添加一个无参数的默认构造函数：

链表最好加一个虚拟头节点，pre，cur